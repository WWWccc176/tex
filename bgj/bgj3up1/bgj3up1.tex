\documentclass{article}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{amssymb}
\usepackage{geometry}
\geometry{textwidth=\dimexpr\textwidth+3cm\relax} % Adjust page margins

\begin{document}

\section{Original Algorithm}

\begin{algorithm}[H] % Using [H] to place it here
\caption{AllPairSearch - bgj3} \label{alg:all_pair_search}
\begin{algorithmic}[1]
\Require{A list $L$ of $N_0$ (n-dimensional) lattice vectors, number of repetitions $(B_0, B_1, B_2)$, filter radius $(\alpha_0, \alpha_1, \alpha_2)$, and a goal norm $\ell$.}
\Ensure{A list of reducing pairs in $L$ with a sum/difference shorter than $\ell$.}
\State $N \gets \emptyset$
\For{$i = 0, 1, \ldots, B_0 - 1$}
    \State Pick a random filter center $c_0$ from $S^{n-1}$
    \State Compute $L_i \gets \{ v \in L \mid v \text{ can pass } F_{c_0, \alpha_0} \}$
    \For{$j = 0, 1, \ldots, B_1/B_0 - 1$}
        \State Pick a random filter center $c_1$ from $S^{n-1}$
        \State Compute $L_{ij} \gets \{ v \in L_i \mid v \text{ can pass } F_{c_1, \alpha_1} \}$
        \For{$k = 0, 1, \ldots,  B_2/B_1  - 1$}
            \State Pick a random filter center $c_2$ from $S^{n-1}$
            \State Compute $L_{ijk} \gets \{ v \in L_{ij} \mid v \text{ can pass } F_{c_2, \alpha_2} \}$
            \State $N \gets N \cup \{ (u, v) \in L_{ijk} \times L_{ijk} \mid \|u \pm v\| < \ell \}$
        \EndFor
    \EndFor
\EndFor
\State \Return $N$
\end{algorithmic}
\end{algorithm}

\section{Definitions}

\textbf{2.1 Dual Lattice:} For a full-rank matrix $\mathbf{B} = (\mathbf{b}_0, \mathbf{b}_1, \ldots, \mathbf{b}_{n-1})$ representing a lattice basis, the lattice generated by this basis is denoted as $\mathcal{L}(\mathbf{B}) = \{ \mathbf{Bx} \mid \mathbf{x} \in \mathbb{Z}^n \}$. The dual lattice of $\mathcal{L}(\mathbf{B})$ is defined as $\mathcal{L}(\mathbf{B}^{\vee})$, where $\mathbf{B}^{\vee} = (\mathbf{b}_0^{\vee}, \mathbf{b}_1^{\vee}, \ldots, \mathbf{b}_{n-1}^{\vee})$ satisfies the inner product relation:
\[
\langle \mathbf{b}_i^{\vee}, \mathbf{b}_j \rangle = \begin{cases} 1 & \text{if } i = j, \\ 0 & \text{otherwise} \end{cases}
\]
Furthermore, $\text{span}(\mathbf{b}_0^{\vee}, \mathbf{b}_1^{\vee}, \ldots, \mathbf{b}_{n-1}^{\vee}) = \text{span}(\mathbf{b}_0, \mathbf{b}_1, \ldots, \mathbf{b}_{n-1})$.\\

\textbf{2.2 Voronoi Filter $F_{c}^{\text{Voronoi}}$ (w.r.t. $\mathbf{B}^{\vee}$):} A vector $v$ passes the Voronoi filter $F_{c}^{\text{Voronoi}}$ if $c$ is the **deterministically determined closest** vector in the dual lattice $\mathcal{L}(\mathbf{B}^{\vee})$ to $v$. This means $v$ is assigned to the Voronoi cell of $c$ using a tie-breaking rule.
\clearpage 

\section{Algorithm 2: Updated Sieve with Algebraic Pre-filter}

\begin{algorithm}[H]
\caption{AllPairSearch - bgj3 (Updated)} \label{alg:all_pair_search_updated}
\begin{algorithmic}[1]
\Require{
    A basis $\mathbf{B}$ for the original lattice $L_0$.
    A list $L$ of $N_0$ vectors from $L_0$.
    Number of centers for each layer $(M_0, M_1, M_2)$. 
    A goal norm $\ell$.
}
\Ensure{A list of reducing pairs $(u, v)$ in $L$ with a sum/difference shorter than $\ell$.}
\State $N_{out} \gets \emptyset$
\State $\mathbf{B}^{\vee} \gets \text{DualBasis}(\mathbf{B})$ \Comment{Compute dual lattice basis}
\State $u_1 \gets \text{FindShortestNonZeroDualLatticeVector}(\mathbf{B}^{\vee})$ \Comment{Select a short vector for coarse sieving}
\State $K_{\text{coarse\_range}} \gets \{0, \pm 1, \pm 2\}$
\State $L_{\text{coarse\_temp}} \gets \emptyset$
\For{each vector $v \in L$}
    \State $k_{\text{val}} \gets \text{round}(\langle v, u_1 \rangle)$
    \If{$k_{\text{val}} \in K_{\text{coarse\_range}}$}
        \State $L_{\text{coarse\_temp}} \gets L_{\text{coarse\_temp}} \cup \{v\}$
    \EndIf
\EndFor
\State $L' \gets L_{\text{coarse\_temp}}$ \Comment{L' is the list after coarse filtering}
\State
\For{$i = 0, 1, \ldots, M_0 - 1$}
    \State $c_0 \gets \text{GetDualLatticeCenter}(i, \mathbf{B}^{\vee})$
    \State $L_i \gets \{ v \in L' \mid \text{FindClosestDualLatticeVector}(v, \mathbf{B}^{\vee}) == c_0 \}$
    \For{$j = 0, 1, \ldots, M_1 - 1$}
        \State $c_1 \gets \text{GetDualLatticeCenter}(j, \mathbf{B}^{\vee})$
        \State $L_{ij} \gets \{ v \in L_i \mid \text{FindClosestDualLatticeVector}(v, \mathbf{B}^{\vee}) == c_1 \}$
        \For{$k = 0, 1, \ldots, M_2 - 1$} 
            \State $c_2 \gets \text{GetDualLatticeCenter}(k, \mathbf{B}^{\vee})$
            \State $L_{ijk} \gets \{ v \in L_{ij} \mid \text{FindClosestDualLatticeVector}(v, \mathbf{B}^{\vee}) == c_2 \}$
            \State $N_{out} \gets N_{out} \cup \{ (u, v) \in L_{ijk} \times L_{ijk} \mid \|u \pm v\| < \ell \}$
        \EndFor
    \EndFor
\EndFor
\State \Return $N_{out}$
\end{algorithmic}
\end{algorithm}


\section{Algorithm 3: AllPairSearch with Hybrid Sieve}

\begin{algorithm}[H]
\caption{AllPairSearch with Hybrid Sieve} \label{alg:hybrid_sieve}
\begin{algorithmic}[1]
\Require{
    The LLL-reduced basis $\mathbf{B}$.
    A list $L_{0}$ of $N_0$ vectors.
    A goal norm $\ell$.
    number of repetitions $(B_0, B_1, B_2)$.
    Number of coarse-sieve vectors $N_{\text{coarse}}$.
    Coarse-sieve integer range $K_{\text{rangeCoarse}}$(\{$0,\pm1,\pm2\}or\{0,\pm1\}$).
}
\Ensure{A list of reducing pairs $(u, v)$ in $L$ with a sum/difference shorter than $\ell$.}
\State $N_{out} \gets \emptyset$
\Statex

\State $\mathbf{B}^{\vee} \gets \text{DualBasis}(\mathbf{B})$
\State $R_{enum\_c}=1.2\lambda _1(\mathcal{L}(B^\vee)) $
\State $C_{\text{dense\_pool}} \gets \text{EnumerateShortDualVectors}(\mathbf{B}^{\vee}, N_{\text{enum\_c}}, R_{enum_c})$ \Comment{Enumerate the $N_{\text{enum-c}}$ shortest dual vectors}
\State Sort $C_{\text{dense\_pool}}$ by increasing norm, lexicographical order if same norm.
\Statex

\State $U_{\text{coarse}} \gets \{ C_{\text{dense\_pool}}[0], C_{\text{dense\_pool}}[1] \}$ \Comment{Select the two shortest vectors {u1, u2}}
\State $L_{\text{filtered}} \gets L_0$
\For{ $\mathbf{u}_1, \mathbf{u}_1 \in U_{\text{coarse}}$}
    \State $L_{\text{temp}} \gets \emptyset$
    \For{each $\mathbf{v} \in L_{\text{filtered}}$}
        \If{($\langle \mathbf{v}, \mathbf{u}_1 \rangle \in K_{\text{rangeCoarse}}\ ||\  \langle \mathbf{v}, \mathbf{u}_2 \rangle \in K_{\text{rangeCoarse}}$)}
            \State $L_{\text{temp}} \gets L_{\text{temp}} \cup \{\mathbf{v}\}$
        \EndIf
    \EndFor
    \State $L_{\text{filtered}} \gets L_{\text{temp}}$ \Comment{Iteratively shrink the list (AND logic)}
\EndFor
\State $L' \gets L_{\text{filtered}}$ \Comment{The final list after multi-vector sieving}
\Statex

\State $C_0 \gets C_{\text{dense\_pool}}[0 \ldots B_0-1]$
\State $C_1 \gets C_{\text{dense\_pool}}[0 \ldots (B_1/B_0)-1]$
\State $C_2 \gets C_{\text{dense\_pool}}[0 \ldots (B_2/B_1)-1]$
\Statex

\For{each $\mathbf{c}_0 \in C_0$}
    \State $L_i \gets \{\mathbf{v} \in L' \mid \text{FindClosestVector}(\mathbf{v}, C_0) == \mathbf{c}_0\}$
    \If{$|L_i| \le 1$} \textbf{continue} \EndIf
    \For{each $\mathbf{c}_1 \in C_1$}
        \State $L_{ij} \gets \{\mathbf{v} \in L_i \mid \text{FindClosestVector}(\mathbf{v}, C_1) == \mathbf{c}_1\}$
        \If{$|L_{ij}| \le 1$} \textbf{continue} \EndIf
        \For{each $\mathbf{c}_2 \in C_2$}
            \State $L_{ijk} \gets \{\mathbf{v} \in L_{ij} \mid \text{FindClosestVector}(\mathbf{v}, C_2) == \mathbf{c}_2\}$
            \If{$|L_{ijk}| > 1$}
                \State $N_{out} \gets N_{out} \cup \{ (u, v) \in L_{ijk}^2 \mid u \neq v, \|u \pm v\| < l \}$
            \EndIf
        \EndFor
    \EndFor
\EndFor
\State \Return $N_{out}$
\end{algorithmic}
\end{algorithm}
\clearpage

\section{Helper Functions (Conceptual)}
\begin{itemize}
    \item \textbf{DualBasis($\mathbf{B}$):} Computes the basis $\mathbf{B}^{\vee}$ for the dual lattice $\mathcal{L}(\mathbf{B}^{\vee})$.
    \item \textbf{FindShortestNonZeroDualLatticeVector($\mathbf{B}^{\vee}$):} Returns a shortest non-zero vector from the dual lattice $\mathcal{L}(\mathbf{B}^{\vee})$.
    \item \textbf{GetDualLatticeCenter(index, $\mathbf{B}^{\vee}$):} Returns the (index+1)-th "short" vector from $\mathcal{L}(\mathbf{B}^{\vee})$ based on a predefined ordering (e.g., by increasing norm or lexicographical order of coefficients of basis combination).
    \item \textbf{FindClosestDualLatticeVector($v$, $\mathbf{B}^{\vee}$):} Solves the CVP for $v$ in the infinite lattice $\mathcal{L}(\mathbf{B}^{\vee})$.
    \item \textbf{EnumerateShortDualVectors($\mathbf{B}^{\vee}, N_{\text{enum-c}}, R_{enum\_c})$:} Runs a lattice enumeration algorithm (e.g., KFP) to find all vectors in $\mathcal{L}(\mathbf{B}^{\vee})$ with norm up to $1.2R_{\text{enum}}$.
    \item \textbf{GenerateDenseCenters($\mathbf{B}^{\vee}, U_{\text{all\_short}}$):} Creates a large, sorted list of candidate centers. This can be a combination of vectors from $U_{\text{all\_short}}$, vectors from the basis $\mathbf{B}^{\vee}$ itself, and short integer linear combinations of the basis vectors.
    \item \textbf{FindClosestVector($\mathbf{v}, C_{\text{set}}$):} Finds the vector in the \textbf{finite set} $C_{\text{set}}$ that is closest to $\mathbf{v}$. This is a simple linear scan, not a CVP problem.
\end{itemize}

\end{document}
