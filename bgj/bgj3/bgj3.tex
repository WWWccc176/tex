\documentclass{article}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{amsmath}
\usepackage{caption}
\usepackage{amssymb}
\usepackage{geometry}
\geometry{textwidth=\dimexpr\textwidth+3cm\relax} % 将文本宽度增加3cm，即缩小页边距

\begin{document}

\section{Original Algorithm}

\begin{algorithm}
\caption{AllPairSearch - bgj3} \label{alg:all_pair_search}
\begin{algorithmic}[1]
\Require{A list $L$ of $N_0$ (n-dimensional) lattice vectors, number of repetitions $(B_0, B_1, B_2)$, filter radius $(\alpha_0, \alpha_1, \alpha_2)$, and a goal norm $\ell$.}
\Ensure{A list of reducing pairs in $L$ with a sum/difference shorter than $\ell$.}
\State $N \gets \emptyset$
\For{$i = 0, 1, \ldots, B_0 - 1$}
    \State Pick a random filter center $c_0$ from $S^{n-1}$
    \State Compute $L_i \gets \{ v \in L \mid v \text{ can pass } F_{c_0, \alpha_0} \}$
    \For{$j = 0, 1, \ldots, B_1/B_0 - 1$}
        \State Pick a random filter center $c_1$ from $S^{n-1}$
        \State Compute $L_{ij} \gets \{ v \in L_i \mid v \text{ can pass } F_{c_1, \alpha_1} \}$
        \For{$k = 0, 1, \ldots,  B_2/B_1  - 1$}
            \State Pick a random filter center $c_2$ from $S^{n-1}$
            \State Compute $L_{ijk} \gets \{ v \in L_{ij} \mid v \text{ can pass } F_{c_2, \alpha_2} \}$
            \State $N \gets N \cup \{ (u, v) \in L_{ijk} \mid \|u \pm v\| < \ell \}$
        \EndFor
    \EndFor
\EndFor
\State \Return $N$
\end{algorithmic}
\end{algorithm}

\section{Definitions}

\textbf{2.1 Dual Lattice:} For a full-rank matrix $\mathbf{B} = (\mathbf{b}_0, \mathbf{b}_1, \ldots, \mathbf{b}_{n-1})$ representing a lattice basis, the lattice generated by this basis is denoted as $\mathcal{L}(\mathbf{B}) = \{ \mathbf{Bx} \mid \mathbf{x} \in \mathbb{Z}^n \}$. The dual lattice of $\mathcal{L}(\mathbf{B})$ is defined as $\mathcal{L}(\mathbf{B}^{\vee})$, where $\mathbf{B}^{\vee} = (\mathbf{b}_0^{\vee}, \mathbf{b}_1^{\vee}, \ldots, \mathbf{b}_{n-1}^{\vee})$ satisfies the inner product relation:
\[
\langle \mathbf{b}_i^{\vee}, \mathbf{b}_j \rangle = \begin{cases} 1 & \text{if } i = j, \\ 0 & \text{otherwise} \end{cases}
\]
Furthermore, $\text{span}(\mathbf{b}_0^{\vee}, \mathbf{b}_1^{\vee}, \ldots, \mathbf{b}_{n-1}^{\vee}) = \text{span}(\mathbf{b}_0, \mathbf{b}_1, \ldots, \mathbf{b}_{n-1})$.\\

\textbf{2.2 Voronoi Filter $F_{c}^{\text{Voronoi}}$ (w.r.t. $\mathbf{B}^{\vee}$):} A vector $v$ passes the Voronoi filter $F_{c}^{\text{Voronoi}}$ if $c$ is the **deterministically determined closest** vector in the dual lattice $\mathcal{L}(\mathbf{B}^{\vee})$ to $v$. This means $v$ is assigned to the Voronoi cell of $c$ using a tie-breaking rule: the order of coordinates if it is equidistant to multiple dual lattice points.
\clearpage % Forces the algorithm to start on a new page

\section{Algorithm2}

\captionof{algorithm}{AllPairSearch - bgj3 (Updated)} \label{alg:all_pair_search_updated}
\begin{algorithmic}[2]
\Require{
    A basis $\mathbf{B}$ for the original lattice $L_0$.
    A list $L$ of $N_0$ (n-dimensional) lattice vectors from $L_0$.
    Number of repetitions $(B_0, B_1, B_2)$.
    A goal norm $\ell$.
}
\Ensure{A list of reducing pairs $(u, v)$ in $L$ with a sum/difference shorter than $\ell$.}
\State $N \gets \emptyset$

\State $\mathbf{B}^{\vee} \gets \text{DualBasis}(\mathbf{B})$ \Comment{Compute dual lattice basis}
\State $u_1 \gets \text{FindShortestNonZeroDualLatticeVector}(\mathbf{B}^{\vee})$ \Comment{Select a short vector from dual lattice (often the shortest)}
\State $K_{\text{coarse\_range}} \gets \{0, \pm 1, \pm 2\}$
\State $L_{\text{coarse\_temp}} \gets \emptyset$
\For{each vector $v \in L$}
    \State $k_{\text{val}} \gets \text{round}(\langle v, u_1 \rangle)$ \Comment{Compute the rounded inner product}
    \If{$k_{\text{val}} \in K_{\text{coarse\_range}}$}
        \State $L_{\text{coarse\_temp}} \gets L_{\text{coarse\_temp}} \cup \{v\}$
    \EndIf
\EndFor
\State $L \gets L_{\text{coarse\_temp}}$ \Comment{Coarse filter $L$ using algebraic partitioning}

\For{$i = 0, 1, \ldots, B_0 - 1$}
    \State $c_0 \gets \text{GetDualLatticeCenter}(i, \mathbf{B}^{\vee})$
    \State $L_i \gets \{ v \in L \mid \text{FindClosestDualLatticeVector}(v, \mathbf{B}^{\vee}) == c_0 \}$
    \For{$j = 0, 1, \ldots, (B_1/B_0) - 1$}
        \State $c_1 \gets \text{GetDualLatticeCenter}(j \cdot B_0 + i, \mathbf{B}^{\vee})$ \Comment{Center determined by global iteration count}
        \State $L_{ij} \gets \{ v \in L_i \mid \text{FindClosestDualLatticeVector}(v, \mathbf{B}^{\vee}) == c_1 \}$
        \For{$k = 0, 1, \ldots, (B_2/B_1) - 1$} 
            \State $c_2 \gets \text{GetDualLatticeCenter}(k \cdot B_1 + j \cdot B_0 + i, \mathbf{B}^{\vee})$
            \State $L_{ijk} \gets \{ v \in L_{ij} \mid \text{FindClosestDualLatticeVector}(v, \mathbf{B}^{\vee}) == c_2 \}$
            \State $N \gets N \cup \{ (u, v) \in L_{ijk} \times L_{ijk} \mid \|u \pm v\| < \ell \}$
        \EndFor
    \EndFor
\EndFor
\State \Return $N$
\end{algorithmic}

\vspace{1em} % Add some space for separation
\section{Helper Functions (Conceptual):}
\begin{itemize}
    \item \textbf{DualBasis($\mathbf{B}$):} Computes the basis $\mathbf{B}^{\vee}$ for the dual lattice $\mathcal{L}(\mathbf{B}^{\vee})$.
    \item \textbf{FindShortestNonZeroDualLatticeVector($\mathbf{B}^{\vee}$):} Returns  shortest non-zero vector from the dual lattice $\mathcal{L}(\mathbf{B}^{\vee})$. This is typically solved using a lattice reduction algorithm.
    \item \textbf{FindClosestVector($v$, $C_{\text{set}}$):} Returns the vector $c' \in C_{\text{set}}$ that minimizes $\|v - c'\|$. (Note: This is still used by the initial coarse filter for historical reasons or specific design; if the algebraic partitioning is the *only* coarse filter, this function might become obsolete.)
    \item \textbf{GetDualLatticeCenter(index, $\mathbf{B}^{\vee}$):} Returns the (index+1)-th "short" vector from $\mathcal{L}(\mathbf{B}^{\vee})$ based on a predefined ordering (e.g. by increasing norm or lexicographical order of coefficients of basis combination). This function ensures the sequential selection of distinct dual lattice centers for the sieve.
    \item \textbf{FindClosestDualLatticeVector($v$, $\mathbf{B}^{\vee}$):} Returns the unique closest vector $c \in \mathcal{L}(\mathbf{B}^{\vee})$ to $v$. If $v$ is equidistant to multiple dual lattice points, a deterministic tie-breaking rule (e.g. based on the order implied by `GetDualLatticeCenter` or a fixed coordinate order) is applied to ensure a single result.
\end{itemize}

\end{document}
